/* 
  Sketch generated by the Arduino IoT Cloud Thing "PortentaIoT"
  https://create.arduino.cc/cloud/things/50507044-bb10-4d6b-b0ab-d8d21df0b2ea 

  Arduino IoT Cloud Properties description

  The following variables are automatically generated and updated when changes are made to the Thing properties

  float Alt;
  float brightness;
  float Pres;
  float temperatura;

  Properties which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include "arduino_secrets.h"
#include "thingProperties.h"

#include <Arduino.h>
#include <Wire.h>

#include <BMx280I2C.h>

#define I2C_ADDRESS 0x76
#define PIN_BRIGHT A0

int brightSensor;

//create a BMx280I2C object using the I2C interface with I2C Address 0x76
BMx280I2C bmx280(I2C_ADDRESS);

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
  Wire.begin();

	//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)
	//and reads compensation parameters.
	if (!bmx280.begin())
	{
		Serial.println("begin() failed. check your BMx280 Interface and I2C Address.");
		while (1);
	}

	if (bmx280.isBME280())
		Serial.println("sensor is a BME280");
	else
		Serial.println("sensor is a BMP280");

	//reset sensor to default parameters.
	bmx280.resetToDefaults();

	//by default sensing is disabled and must be enabled by setting a non-zero
	//oversampling setting.
	//set an oversampling setting for pressure and temperature measurements. 
	bmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);
	bmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);
	
	//INIT ADC
  pinMode(PIN_BRIGHT, INPUT);
  brightSensor = analogRead(PIN_BRIGHT);
  
  //Init built led
  pinMode(LEDG, OUTPUT);      // set the Green LED pin mode
  digitalWrite(LEDG, LOW);
  pinMode(LEDR, OUTPUT);      // set the Red LED pin mode
  digitalWrite(LEDR, LOW);

  setAlarm = 25;
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  //Led green blinks for notify measurement:
  digitalWrite(LEDG, LOW);
  delay(500);
  digitalWrite(LEDG, HIGH);
  //start a measurement
	if (!bmx280.measure())
	{
		Serial.println("could not start measurement, is a measurement already running?");
		return;
	}

	//wait for the measurement to finish
	do
	{
		delay(100);
	} while (!bmx280.hasValue());
	
  brightSensor = analogRead(PIN_BRIGHT);
  brightness = 500 / (10.0 * (3.3 - (float)brightSensor / 1023 * 3.3) / ((float)brightSensor / 1023 * 3.3));
  Pres = bmx280.getPressure();
  temperatura = bmx280.getTemperature();
  
	Serial.print("Pressure: "); Serial.println(Pres);
	Serial.print("Brillo: "); Serial.println(brightness);
	Serial.print("Temperature: "); Serial.println(temperatura);
  delay(3000); //3 secs
  

  
  ledRojo = LEDR;
}

void onSetAlarmChange() {

  if(temperatura>setAlarm) {digitalWrite(LEDR, LOW);}
  else {digitalWrite(LEDR, HIGH);}
}
